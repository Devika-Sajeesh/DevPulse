# DevPulse â€“ Predictive Code Health & Technical Debt Engine

DevPulse is a **full-stack predictive code analysis platform** built with **FastAPI**, **React**, and integrated machine learning. It transcends traditional static analysis by delivering a single, objective **Code Health Score (CHS)**, which estimates future technical debt and maintainability risk.

## âœ¨ Predictive Core

The central feature is the **Code Health Score (CHS)**, a weighted metric (0-100) combining three powerful elements to create a forward-looking risk assessment:

| Metric                            | Component        | Role in Prediction | Description                                                                                                                                                                                           |
| :-------------------------------- | :--------------- | :----------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Code Health Score (CHS)**       | **Final Output** | **Synthesis**      | A single, actionable score for overall code quality, maintainability, and future risk.                                                                                                                |
| **AI Code Probability ($w_2$)**   | **LLM Insight**  | **Penalty**        | Estimates the probability (0-100%) that the code was substantially generated by an LLM (e.g., Groq/OpenAI), flagging potential maintenance risks associated with AI-generated code.                   |
| **Historical Risk Score ($w_3$)** | **ML Model**     | **Penalty**        | Predicts the likelihood of new, high-severity technical debt based on features (like complexity, line count) fed into a trained **Scikit-learn** model, replacing the previous placeholder heuristic. |

## ğŸ“Š Feature Extraction

DevPulse integrates and parses outputs from industry-standard tools to form the **Static Score ($w_1$)** and the core **Feature Vector** used by the ML model:

- **Radon:** Cyclomatic complexity, raw metrics (LOC, comments).
- **Cloc:** Lines of code breakdown (code, comments, blank).
- **Pylint:** Comprehensive code quality, style, and issue detection (The primary input for the Static Score).

## ğŸ—ï¸ Architecture

DevPulse uses a modern, performant microservice architecture designed for scale:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   React App   â”‚  <-->  â”‚   FastAPI   â”‚
â”‚  (Frontend)   â”‚        â”‚  (Backend)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
        â”‚                         â”‚
        â–¼                         â–¼
  Predictive UI            Static Analysis Tools
  (CHS Gauge)
                             â”‚
                             â–¼
                         ğŸ¤– LLM Service (w2)
                         ğŸ§  ML Model (w3)  <-- Uses joblib/Scikit-learn
                             â”‚
                             â–¼
                        ğŸ’¾ SQLite DB (History & Reports)
```

**Key Architectural Features:**

- **ML Model Persistence:** The Scikit-learn model is trained offline (`ml/train_model.py`) and loaded on application startup using **joblib**, ensuring predictions are fast and consistent.
- **Asynchronous Processing:** Analysis runs are executed non-blocking via `asyncio.gather` for optimized performance.
- **History Tracking:** Each analysis saves the **Git Commit SHA** and all predictive metrics, enabling future features like historical trending.

## âš¡ Quick Start

### 1\. Clone the repo & Setup Directories

```bash
git clone <your_repo_url>
cd DevPulse
```

### 2\. Backend Setup & ML Training

You must install dependencies (including `scikit-learn`), train the model, and then start the API.

```bash
cd backend
python -m venv venv
source venv/bin/activate
pip install -r ../requirements.txt
cd .. # Go back to root

# 1. TRAIN THE ML MODEL
# This creates the file ml/historical_risk_model.joblib
python ml/train_model.py

# 2. START FASTAPI
# This command loads the trained model on startup
uvicorn backend.main:app --reload
```

**Configuration:** Ensure you have a **`.env`** file with `GROQ_API_KEY` or `OPENAI_API_KEY` for the $w_2$ calculation.

### 3\. Frontend Setup

Open a **new terminal window** and run:

```bash
cd frontend
npm install
npm start
```

Frontend â†’ `http://localhost:3000`
Backend â†’ `http://127.0.0.1:8000`

## ğŸ› ï¸ Tech Stack

- **Frontend**: React, Code Health Gauge, Premium CSS Theming
- **Backend**: FastAPI, Python 3.11+
- **ML/AI**: Scikit-learn (Linear Regression), joblib, Groq/OpenAI LLM APIs
- **Data**: SQLite, GitPython, Radon, Cloc, Pylint.

## ğŸš§ Next Steps on Roadmap

- **Security:** Implement **Docker sandboxing** for code analysis to securely isolate repository cloning and static analysis.
- **Visualization:** Implement CHS trending over time by displaying plots of historical reports from the database.
- **Production Deployment:** Scale persistence from SQLite to **Postgres/Redis**.
